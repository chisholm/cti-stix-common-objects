{
    "type": "bundle",
    "id": "bundle--bb85fb7c-15bd-4ffa-805a-a744cb054fc2",
    "objects": [
        {
            "type": "vulnerability",
            "spec_version": "2.1",
            "id": "vulnerability--04d446c0-b2f3-4ac1-91fe-c2e9a0379c71",
            "created_by_ref": "identity--8ce3f695-d5a4-4dc8-9e93-a65af453a31a",
            "created": "2024-07-16T00:18:04.572102Z",
            "modified": "2024-07-16T00:18:04.572102Z",
            "name": "CVE-2024-40935",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncachefiles: flush all requests after setting CACHEFILES_DEAD\n\nIn ondemand mode, when the daemon is processing an open request, if the\nkernel flags the cache as CACHEFILES_DEAD, the cachefiles_daemon_write()\nwill always return -EIO, so the daemon can't pass the copen to the kernel.\nThen the kernel process that is waiting for the copen triggers a hung_task.\n\nSince the DEAD state is irreversible, it can only be exited by closing\n/dev/cachefiles. Therefore, after calling cachefiles_io_error() to mark\nthe cache as CACHEFILES_DEAD, if in ondemand mode, flush all requests to\navoid the above hungtask. We may still be able to read some of the cached\ndata before closing the fd of /dev/cachefiles.\n\nNote that this relies on the patch that adds reference counting to the req,\notherwise it may UAF.",
            "external_references": [
                {
                    "source_name": "cve",
                    "external_id": "CVE-2024-40935"
                }
            ]
        }
    ]
}